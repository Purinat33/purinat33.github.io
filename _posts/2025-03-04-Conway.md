---
title: "Conway's Game of Life"
categories: [Software Development, Game]
toc: true
---

# Conway’s Game of Life in Java

A Java implementation of Conway’s Game of Life that simulates a 2D cellular automaton with configurable grid size, random or preset starting patterns, and step-by-step output logging.

- Repo: https://github.com/Purinat33/Conway/blob/master/src/com/example/demo/Game.java

---

## What this project demonstrates

- Turning a well-known set of rules into a working simulation
- Modeling a grid system using clean object-oriented structure
- Handling “read → compute next generation → display/log” in a repeatable loop
- Supporting multiple initialization modes (random and preset patterns)

---

## Rules (the core logic)

The game runs on a 2D grid where each cell is either:

- Alive (`'L'`)
- Dead (`'D'`)

Each generation is computed from the **eight neighbors**:

1. Underpopulation: live cell with < 2 live neighbors dies
2. Survival: live cell with 2–3 live neighbors stays alive
3. Overpopulation: live cell with > 3 live neighbors dies
4. Reproduction: dead cell with exactly 3 live neighbors becomes alive

---

## Architecture

I organized the program into three core responsibilities:

- **Cell**: represents state (`'L'` or `'D'`)
- **Board**: owns the grid and computes neighbor counts / next state
- **Game**: runs the simulation loop and outputs each iteration

This keeps the simulation logic separate from the “runner” code.

---

## Key implementation details

### Cell model

```java
public class Cell {
    private char state; // 'D' for Dead, 'L' for Live

    public Cell(char state) { this.state = state; }
    public void setState(char state) { this.state = state; }
    public char getState() { return state; }
}
```

### Board initialization (random start)

```java
public void initBoard() {
    for (int i = 0; i < boardSize; i++) {
        for (int j = 0; j < boardSize; j++) {
            board[i][j] = new Cell('D');
        }
    }
    randomBoard();
}

public void randomBoard() {
    Random r = new Random();
    for (int i = 0; i < boardSize; i++) {
        for (int j = 0; j < boardSize; j++) {
            if (r.nextBoolean()) board[i][j].setState('L');
        }
    }
}
```

> Note: The important part of Game of Life is computing the next generation without corrupting the current generation. A typical approach is to build a separate “next board” from the current board, then swap.

### Simulation runner + file logging

```java
public class Game {
    public static void main(String[] args) throws FileNotFoundException {
        PrintStream fileOutput = new PrintStream(new File("output.txt"));
        System.setOut(fileOutput);

        Board board = new Board(20);
        for (int iteration = 0; iteration < 100; iteration++) {
            board.run(iteration);
        }
    }
}
```

---

## Features

- **Randomized initial state** for experimentation
- **Preset patterns** (e.g., Blinker, Glider) to validate correctness
- **Configurable board size** (e.g., 20×20)
- **Log output** (stores generations in `output.txt` for review)

---

## Core update loop (double buffering)

To avoid corrupting the current generation while computing the next one, the simulation uses **double buffering**: it calculates all next states into a temporary grid, then swaps it in as the new board.

```java
public void run(int iteration) {

    Cell[][] temp = new Cell[boardSize][boardSize];
    for (int i = 0; i < boardSize; i++) {
        for (int j = 0; j < boardSize; j++) {
            temp[i][j] = new Cell('D');
        }
    }

    System.out.println("Iteration: " + iteration);
    System.out.println("----------------");

    for (int row = 0; row < boardSize; row++) {
        for (int col = 0; col < boardSize; col++) {
            int neighbor = this.getLivingNeighbours(this.getBoard(), row, col);
            temp[row][col].setState(
                this.getNextState(neighbor, board[row][col].getState())
            );
        }
    }

    this.board = temp;

    printBoard();
    System.out.println("----------------");
}
```

**Why this matters:** if you update cells in-place, later neighbor counts would accidentally use already-updated cells from the same iteration. Using a temporary board ensures each generation is computed from a consistent snapshot.

---

## Challenges / considerations

- **Neighbor counting at borders**: handling edges without out-of-bounds errors
  (common strategies: bounds checks, wrapping edges, or padding)
- **Correct generation updates**: ensuring the next state uses the previous generation’s values
- **Reproducibility**: optional improvement is seeding the random generator for repeatable runs

---

## Future improvements

- **Visualization**: JavaFX/Swing UI with step/pause/speed control
- **Custom pattern input**: allow users to place live cells interactively or load patterns from a file
- **Performance**: optimize neighbor counting or use sparse structures for large boards
- **Export formats**: save as CSV or render frames for GIF/video output

---

## Final thoughts

This project shows how simple local rules can produce complex global behavior, while also reinforcing core programming skills: grid-based algorithms, state transitions, and clean separation of responsibilities in Java.
